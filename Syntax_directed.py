class Node:
    """Base class for AST nodes."""

    def __init__(self, children=None):
        # Initialize the children nodes, if any, and a list to hold generated code
        self.children = children if children else []
        self.code = []  # Code generated by this node


class ExpressionNode(Node):
    """Node for expressions, such as binary arithmetic operations."""

    def __init__(self, op, left, right):
        # 'op' is the operator (e.g., +, -, *, /), and left/right are child nodes
        super().__init__([left, right])
        self.op = op

    def generate_code(self):
        # Generate code for the left and right operands recursively
        left_code = self.children[0].generate_code()
        right_code = self.children[1].generate_code()

        # Create a new temporary variable to store the result of the expression
        temp_var = new_temp_var()

        # Generate code by combining left, right, and current operation
        # e.g., t0 = left_result + right_result
        self.code = left_code + right_code + [
            f"{temp_var} = {self.children[0].result} {self.op} {self.children[1].result}"]

        # Store result in temp_var for use by parent nodes
        self.result = temp_var
        return self.code


class NumberNode(Node):
    """Node for a constant number, used in expressions."""

    def __init__(self, value):
        super().__init__()
        self.value = value  # Store the constant value

    def generate_code(self):
        # For a constant, there is no code to generate
        # Set result directly to this constant value
        self.result = self.value
        return []


class AssignmentNode(Node):
    """Node for assignment statements, such as x = expr."""

    def __init__(self, var_name, expr):
        # 'var_name' is the variable being assigned, and 'expr' is the expression node
        super().__init__([expr])
        self.var_name = var_name

    def generate_code(self):
        # Generate code for the expression on the right-hand side
        expr_code = self.children[0].generate_code()

        # Combine the expression code with the assignment to var_name
        self.code = expr_code + [f"{self.var_name} = {self.children[0].result}"]
        return self.code


class WhileNode(Node):
    """Node for while loops, with a condition and a body."""

    def __init__(self, condition, body):
        # 'condition' is the loop condition, and 'body' is the code block to execute
        super().__init__([condition, body])

    def generate_code(self):
        # Create labels for the start and end of the loop
        start_label = new_label()
        end_label = new_label()

        # Generate code for the loop condition and body
        cond_code = self.children[0].generate_code()
        body_code = self.children[1].generate_code()

        # Loop code structure:
        # 1. Label for loop start
        # 2. Condition check and jump to end if false
        # 3. Loop body
        # 4. Jump back to start label
        # 5. End label
        self.code = [
            f"{start_label}:",
            *cond_code,
            f"if not {self.children[0].result} goto {end_label}",
            *body_code,
            f"goto {start_label}",
            f"{end_label}:"
        ]
        return self.code


# Utility functions for generating unique temporary variables and labels
temp_var_counter = 0
label_counter = 0


def new_temp_var():
    """Generate a new temporary variable name."""
    global temp_var_counter
    temp_var = f"t{temp_var_counter}"
    temp_var_counter += 1
    return temp_var


def new_label():
    """Generate a new label name."""
    global label_counter
    label = f"L{label_counter}"
    label_counter += 1
    return label


# Example usage:
# Building an AST for: x = (3 + 4) * 5;
# Creates the expression (3 + 4) * 5 and assigns it to x
expr = ExpressionNode('*', ExpressionNode('+', NumberNode(3), NumberNode(4)), NumberNode(5))
assignment = AssignmentNode("x", expr)

# Generate and print intermediate code
print("\n".join(assignment.generate_code()))
